# Daily Standup Report Workflow

**Project**: {{ project.name }}
**Workflow**: Daily Standup Report
**Purpose**: Generate automated daily standup reports for the active sprint

## Output Formatting Requirements

**IMPORTANT**: When generating reports, use actual Unicode emojis, NOT GitHub-style shortcodes:
- âœ… Correct: `âš ï¸ Warning` or `â„¹ï¸ Info`
- âŒ Incorrect: `:warning:` or `:information_source:`

Status indicators to use:
- âœ… Completed / On track
- âš ï¸ Warning / Below target
- âŒ Critical / Blocked
- â„¹ï¸ Information
- ðŸ”´ High priority
- ðŸŸ¡ Medium priority
- ðŸŸ¢ Low priority / Good

## Overview

This lightweight workflow generates daily standup reports showing what was completed yesterday, what's planned for today, and any blockers. Perfect for distributed teams or async standups.

## Prerequisites

- Active sprint in {{ work_tracking.platform }}
- Work items with recent activity

## Initialize Work Tracking

```python
# Initialize work tracking adapter (auto-selects Azure DevOps or file-based)
import sys
sys.path.insert(0, ".claude/skills")
from work_tracking import get_adapter
from datetime import datetime, timedelta

adapter = get_adapter()
print(f"ðŸ“‹ Work Tracking: {adapter.platform}")

# Get current sprint name (replace CURRENT_SPRINT with actual sprint)
current_sprint = "Sprint 1"  # Update this
```

## Workflow Steps

### Step 1: Gather Yesterday's Activity

1. **Query completed work (last 24 hours):**
   ```python
   # Get work items from the current sprint
   sprint_items = adapter.query_sprint_work_items(current_sprint)

   # Filter for items updated in last 24 hours
   yesterday = datetime.now() - timedelta(days=1)
   recent_items = [
       item for item in sprint_items
       if datetime.fromisoformat(item.get('updated_at', '2000-01-01')) >= yesterday
   ]

   print(f"Found {len(recent_items)} items updated since yesterday")
   for item in recent_items:
       print(f"  WI-{item['id']}: {item['title']} [{item['state']}]")
   ```

2. **Categorize changes:**
   - âœ… Completed: Items moved to "Done"/"Closed"
   - âš™ï¸ In Progress: Items actively worked on
   - ðŸ†• Started: Items moved from "New" to "Active"
   - ðŸš« Blocked: Items marked as blocked
   - ðŸ’¬ Discussed: Items with new comments

### Step 1.5: Verify Work Item States Against External Source of Truth

**CRITICAL**: This step implements the "External Source of Truth" pattern from VISION.md. AI agents often claim work is complete when it isn't. This verification step catches divergence immediately.

1. **Query adapter for actual work item states:**
   ```python
   # Query adapter directly for items updated yesterday (external source of truth)
   print("\nðŸ” Verifying work item states against external source of truth...")

   # Build map of actual current states from adapter
   actual_state_map = {}
   for item in recent_items:
       item_id = item['id']
       # Query adapter for current state (external truth)
       current_item = adapter.get_work_item(item_id)
       if current_item:
           actual_state_map[item_id] = current_item.get('state', 'UNKNOWN')
       else:
           actual_state_map[item_id] = 'NOT_FOUND'
   ```

2. **Detect state divergences:**
   ```python
   # Terminal states that indicate completion
   terminal_states = ['Done', 'Closed', 'Completed', 'Resolved']

   # Track divergences between claimed state and actual state
   divergences = []

   for item in recent_items:
       item_id = item['id']
       item_title = item.get('title', 'Unknown')
       claimed_state = item.get('state', 'Unknown')
       actual_state = actual_state_map.get(item_id, 'NOT_FOUND')

       # Divergence: claimed terminal but actually not terminal
       if claimed_state in terminal_states and actual_state not in terminal_states:
           if actual_state == 'NOT_FOUND':
               divergences.append({
                   'id': item_id,
                   'title': item_title,
                   'claimed_state': claimed_state,
                   'actual_state': actual_state,
                   'severity': 'ERROR',
                   'message': f"Work item claimed to exist in state '{claimed_state}' but not found in {adapter.platform}"
               })
           else:
               divergences.append({
                   'id': item_id,
                   'title': item_title,
                   'claimed_state': claimed_state,
                   'actual_state': actual_state,
                   'severity': 'WARNING',
                   'message': f"State mismatch: claimed '{claimed_state}' but adapter shows '{actual_state}'"
               })

       # Divergence: work item doesn't exist in adapter
       elif actual_state == 'NOT_FOUND':
           divergences.append({
               'id': item_id,
               'title': item_title,
               'claimed_state': claimed_state,
               'actual_state': actual_state,
               'severity': 'ERROR',
               'message': f"Work item not found in {adapter.platform}"
           })
   ```

3. **Output divergence warnings (informational only - workflow continues):**
   ```python
   # Display divergence summary
   if divergences:
       print(f"\nâš ï¸ DIVERGENCE DETECTED: {len(divergences)} work item(s) need attention")
       print("=" * 80)

       for div in divergences:
           if div['severity'] == 'ERROR':
               print(f"  âŒ {div['id']}: {div['title']}")
               print(f"     {div['message']}")
           else:
               print(f"  âš ï¸ {div['id']}: {div['title']}")
               print(f"     CLAIMED: {div['claimed_state']} | ACTUAL: {div['actual_state']}")

       print(f"\nðŸ“Š Divergence Summary:")
       print(f"   - {len([d for d in divergences if d['severity'] == 'ERROR'])} ERROR(s)")
       print(f"   - {len([d for d in divergences if d['severity'] == 'WARNING'])} WARNING(s)")
       print(f"   - Action: Review work items and sync states in {adapter.platform}")
       print("=" * 80)
   else:
       print("âœ… No divergence detected - all work item states match external source of truth")

   # Store divergences for inclusion in report (Step 5)
   divergence_summary = {
       'count': len(divergences),
       'errors': [d for d in divergences if d['severity'] == 'ERROR'],
       'warnings': [d for d in divergences if d['severity'] == 'WARNING']
   }
   ```

### Step 2: Identify Today's Focus

1. **Query active work items:**
   ```python
   # Get active work items for current sprint
   active_states = ['Active', 'In Progress', 'Doing']
   active_items = [
       item for item in adapter.query_sprint_work_items(current_sprint)
       if item.get('state') in active_states
   ]

   print(f"\nðŸ“‹ Active Work Items ({len(active_items)}):")
   for item in active_items:
       points = item.get('story_points', item.get('fields', {}).get('Microsoft.VSTS.Scheduling.StoryPoints', '-'))
       assignee = item.get('assigned_to', 'Unassigned')
       print(f"  WI-{item['id']}: {item['title']}")
       print(f"    State: {item['state']} | Points: {points} | Assigned: {assignee}")
   ```

2. **Group by team member:**
   - List active items per person
   - Identify items without updates
   - Flag items at risk

### Step 3: Detect Blockers

1. **Find blocked items:**
   - Items with "Blocked" state
   - Items tagged with "blocker"
   - Items with no updates in 3+ days
   - Items mentioned in comments as blocked

2. **Analyze blocker impact:**
   - Number of people affected
   - Story points at risk
   - Sprint goal impact

{% if config.is_agent_enabled('scrum-master') %}
### Step 4: Generate Standup Report

1. **Read agent definition:** `.claude/agents/scrum-master.md`
2. **Task:** "Generate a concise daily standup report:
   - Summarize yesterday's accomplishments
   - List today's planned work by team member
   - Highlight blockers requiring attention
   - Include work item state verification results (divergences from Step 1.5)
   - Note sprint progress toward goal
   - Keep it brief and action-oriented"
3. **Spawn agent** using Task tool with model `{{ config.get_agent_model('scrum-master') or 'haiku' }}`
4. **Input:** Yesterday's activity, today's active items, blockers, divergence_summary
5. **Display output** to user

{% endif %}
### Step 5: Format and Distribute Report

Generate report in markdown format (template shown below with placeholder data that would be filled at runtime).

**IMPORTANT**: Include divergence summary section if any divergences were detected:

```python
# Generate report with divergence section
report = f"""
# Daily Standup Report
**Date**: {datetime.now().strftime('%Y-%m-%d')}
**Sprint**: {current_sprint}

## Yesterday's Accomplishments
[List completed work items from recent_items]

## Work Item State Verification
"""

# Add divergence section
if divergence_summary['count'] > 0:
    report += f"âš ï¸ **DIVERGENCE DETECTED**: {divergence_summary['count']} work item(s) need attention\n\n"

    if divergence_summary['errors']:
        report += f"### Errors ({len(divergence_summary['errors'])})\n"
        for error in divergence_summary['errors']:
            report += f"- âŒ **{error['id']}**: {error['title']}\n"
            report += f"  - {error['message']}\n"
        report += "\n"

    if divergence_summary['warnings']:
        report += f"### Warnings ({len(divergence_summary['warnings'])})\n"
        for warning in divergence_summary['warnings']:
            report += f"- âš ï¸ **{warning['id']}**: {warning['title']}\n"
            report += f"  - Claimed: {warning['claimed_state']} | Actual: {warning['actual_state']}\n"
        report += "\n"

    report += f"**Action Required**: Review and sync work item states in {adapter.platform}\n\n"
else:
    report += "âœ… **All work item states verified** - no divergence detected\n\n"

report += """
## Today's Focus
[List planned work items from active_items]

## Blockers
[List blockers requiring attention]

## Sprint Progress
[Progress toward sprint goal]
"""
```

### Step 6: Distribute Report

1. **Save to file:**
   ```bash
   # Save to reports directory
   mkdir -p .claude/reports/daily
   echo "$report" > .claude/reports/daily/$(date +%Y-%m-%d)-standup.md
   ```

2. **Post to team channels** (configure webhook URLs in environment)

3. **Email to stakeholders** (optional)

## Automation Setup

### Run Automatically Every Morning

**GitHub Actions** (`.github/workflows/daily-standup.yml`):
{% raw %}
```yaml
name: Daily Standup Report

on:
  schedule:
    - cron: '0 9 * * 1-5'  # Weekdays at 9 AM
  workflow_dispatch:  # Manual trigger

jobs:
  standup-report:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install framework
        run: pip install trustable-ai

      - name: Generate standup report
        env:
          AZURE_DEVOPS_PAT: ${{ secrets.AZURE_DEVOPS_PAT }}
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          cwf workflow run daily-standup

      - name: Commit report
        run: |
          git config user.name "Daily Standup Bot"
          git config user.email "bot@yourcompany.com"
          git add .claude/reports/daily/
          git commit -m "Daily standup report $(date +%Y-%m-%d)" || true
          git push
```
{% endraw %}

**Azure DevOps Pipeline** (`azure-daily-standup.yml`):
{% raw %}
```yaml
schedules:
  - cron: "0 9 * * 1-5"
    displayName: Daily Standup Report
    branches:
      include:
        - main
    always: true

steps:
  - task: UsePythonVersion@0
    inputs:
      versionSpec: '3.10'

  - script: |
      pip install trustable-ai
      cwf workflow run daily-standup
    displayName: 'Generate Daily Standup'
    env:
      AZURE_DEVOPS_PAT: $(AZURE_DEVOPS_PAT)
      TEAMS_WEBHOOK_URL: $(TEAMS_WEBHOOK_URL)
```
{% endraw %}

### Manual Execution

```bash
# Generate today's standup report
cwf workflow run daily-standup

# Generate for specific date
cwf workflow run daily-standup --date 2025-01-15

# Dry run (preview without posting)
cwf workflow run daily-standup --dry-run
```

## Integration with Team Tools

### Slack Integration
Set environment variable:
```bash
export SLACK_WEBHOOK_URL="https://hooks.slack.com/services/YOUR/WEBHOOK/URL"
```

### Microsoft Teams Integration
Set environment variable:
```bash
export TEAMS_WEBHOOK_URL="https://outlook.office.com/webhook/YOUR/WEBHOOK/URL"
```

## Success Criteria

- âœ… Report generated every weekday morning
- âœ… Delivered to team channels within 5 minutes
- âœ… Blockers clearly highlighted
- âœ… Team members know what others are working on
- âœ… Sprint progress visible at a glance

## Configuration

**Agents Used:**
{% if config.is_agent_enabled('scrum-master') %}- Scrum Master (report generation and formatting){% endif %}

**Report Schedule:**
- **Daily**: Weekdays at 9 AM
- **Duration**: < 1 minute to generate
- **Distribution**: Slack/Teams/Email

**Work Item Types Tracked:**
- {{ work_tracking.work_item_types.story or 'User Story' }}
- {{ work_tracking.work_item_types.task or 'Task' }}
- {{ work_tracking.work_item_types.bug or 'Bug' }}

---

*Generated by Trustable AI Workbench for {{ project.name }}*
